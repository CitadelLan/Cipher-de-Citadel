[{"content":"数据库并发 数据库事务 事务的四大特性/ACID: A/原子性：单个事务执行期间不可只执行部分操作，即一个事务只会完成或不完成其中所有操作，若操作期间出错则回滚该事物已经进行的操作 C/一致性：事务进行前、结束后，数据库完整性不被破坏。例如A向B转账，A一定会扣钱，B一定会得到等量的钱，不允许A扣钱数量与B得到钱的数量不一致 I/隔离性（操作语句的原子性）：事务在执行某一操作时（可以理解为执行某一条SQL语句时），其他事务不可对这一事务相关的数据进行操作 D/持久性：事务提交后，这一事务对数据的改变是永久的 数据库并发情境下的问题 不可重复读：一个事务读取到了同一个变量在经其他事务修改前后，值不一致的情况。例如A对变量var进行修改，B前后读取var的值是不一样的 幻影读：对于同一限定范围的数据，一个事务只负责读，另一事物往其中添加数据。这使得读方每次查询得到的数据数量不同 不可重复读和幻影读是很类似的情形，两者在数据的查询范围上有所不同：\n不可重复读针对的是单个数据的值 幻影读针对的是一个范围的数据的总数 脏读：读取到了被回滚前的数据（脏数据）。例如B读取到缓存中由A进行的修改操作后（该修改还未提交），A又回滚了该操作，与数据库中的实际值不同。 丢弃修改：两个事务先后修改一个值，前者读取到了后者修改的数据，与自己的修改值不一致 数据库并发问题的解决方案 数据库隔离级别 未提交读：相当于没有隔离，未提交的修改对其他事务可见 提交读：仅提交的修改对其他事务可见，避免了脏读 数据被修改，但未被提交，则该数据不会对其他事务可见，即使此时回滚也不会影响其他事务读取到该数据的结果\n重复读：已有数据被读取期间，其他事务不可修改已有的部分，但允许其他事务插入记录，避免脏读和不可重复读 串行化读：有数据被读取期间，其他事务不可修改该数据 数据库锁机制 锁类型 一般锁 共享锁：允许对数据\\[行/表\\]进行读，在数据\\[行/表\\]有共享锁时，无法申请排它锁（不允许写） 排它锁：允许对数据\\[行/表\\]进行写（更新/删除），在数据\\[行/表\\]有排它锁时，无法申请共享锁、排它锁 意向锁（意向锁一定为表锁） 意向锁的出现是为了表示该表目前有一部分行有共享锁/排它锁，是一种以偏概全的表示形式。\n在向某些行申请共享锁/排它锁时，会先向数据所在表申请对应的意向共享锁/排它锁\n例：要对表中id=6的数据加排它锁前，系统会先向这个表申请意向排它锁\n意向共享锁：意向共享锁代表了目前需要向表中部分行加上共享锁，如果该表已经加有排他锁，则意向共享锁的申请会被阻塞直至排它锁解除 意向排它锁：意向排它锁代表了目前需要向表中部分行加上排他锁，如果该表已经加有共享锁/排他锁，则意向排它锁的申请会被阻塞直至这一非共享锁解除 锁 共享锁 S 排它锁 X 意向共享锁 IS 意向排它锁 IX 共享锁 S √ × √ × 排它锁 X × × × × 意向共享锁 IS √ × √ √ 意向排它锁 IX × × √ √ 死锁：两个事务不提交，由于锁机制导致的两边事务互卡 死锁的产生\n条件\n互斥条件：资源被进程排他地占用。进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。 保持并等待条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。 不可剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放。 循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。 举个例子：\n1 2 3 4 5 6 7 session 1 : session 2： select * from t where id = 1 for update; select * from t where id = 2 for update; update t set name = \u0026#39;Cipher\u0026#39; where id = 2; 等待session2的第一句的排它锁释放 update t set name = \u0026#39;Anima\u0026#39; where id = 1; 等待session1的第一句的排它锁释放 如果上面两个事务都不提交，则两个事务各自成功申请的申请的的排它锁就不会释放（session1-\u0026gt;id=1的排它锁，session2-\u0026gt;id=2的排它锁）就会相互等待对方的排它锁释放，从而卡住\nMySQL的死锁解决方案\n锁超时：一个事务长时间无法获取锁的时候，主动放弃等待（取消事务），但超时阈值难以确定 阈值太短，容易将一些需要稍等一段时间才可以获取到锁的事务提前取消，然后回滚，之后再重新获取锁。这一操作是没有意义的，造成了性能浪费 阈值太长，容易卡住太多的事务，使得这一数据库给人感觉反应不够快 死锁检测：采用wait-for graph算法 每个锁被什么事务持有（锁的信息链表），被阻塞的事务在等待什么锁（事务等待链表）。 每当一个事务需要阻塞等待某个锁时，就会触发一次wait-for graph算法 从「锁的信息链表」中尝试寻找该锁，如果存在，则查找被哪个事务所持有 根据上一步找到的的事务，在「事务等待链表」中进行查找，看看持有锁的事务是否在等待获取其他锁，如果是，则再去看看另一个持有锁的事务，是否在等待其他锁\u0026hellip;..，经过一系列的判断后，再看看是否会出现闭环 如果出现了闭环，MySQL会选择回滚量最小的事务，如果有回滚量最小的事务不止一个，则回滚其中一个，这一选择需要根据策略的选择来决定（随机、事务ID、优先级） ","date":"2025-03-02T14:14:55+08:00","permalink":"https://citadellan.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AC%94%E8%AE%B0/","title":"数据库知识点笔记"}]