[{"content":"数据库分类 关系型数据库 关系型数据库中，数据 == 一系列（表 == 一组列/行）\n+ 支持事务，满足ACID原则 + 支持复杂查询、事务 + 数据更新的成本相对较低 + 支持JOIN查询，允许同时显示多表查询的结果 - 扩展性不足 当表的字段数量产生改变时，整个表的存储结构就会发生变化，这就需要对原来的表的数据进行迁移与增删，这一操作复杂性高 如果将数据放在一台服务器上，则由于单个服务器的容量有限，随着数据量增大，容易达到单台服务器的瓶颈 如果将数据分布到多个服务器，则需要考虑多台服务器间的一致性问题，而该问题通常极其棘手 - 对大批量数据的查询效率底下 - 不支持非结构化数据 非关系型数据库 非关系型数据库的存储形式多样，其中：\nKey-Value DB：数据 == 一系列k-v对（Redis） + 查询快 Document DB：数据 == 文档（一般为json）（MongoDB） + 适用于架构无法定义/频繁更改的非结构化数据 Columnar DB：将原来关系数据库中的行以列的形式存储 + 可以更快访问列数据，适用于数据分析 Graph DB：数据存储在节点中，节点间关系存储在边上 + 更快的复杂关系查询 由于非关系型数据库支持非结构化数据的存储，也带来了以下特点：\n+ 数据模型更加灵活，不需要像关系型数据库中一样进行大量的相同内容的数据迁移 + 更好的可扩展性，上一条已经解释了原因，而这一性质更契合分布式存储 + 处理大规模数据、高并发访问效率更高（由于分布式存储） - 缺乏事务支持 - 数据一致性差 MySQL 数据库操作 Drop：删除整个表 Truncate：删除表中所有数据 Delete：删除一部分/全部表数据，需要commit才可生效，可rollback 数据库操作优化 尽可能避免使用select * 查询出一些可能不需要的字段，即磁盘IO时产生了资源浪费 为搜索字段创建索引 垂直分割分表 定义：将一个表中的列根据功能或使用频率等原则拆分为多个表。每个子表只包含原表中的部分列，通过主键或唯一索引关联各个子表。 通过分割行为，得到了多张宽度更小的表，在查询时的表更小，冗余的IO更少 分离冷/热数据：使用频率低/高的数据，减少冗余IO 更小的表宽度意味着一页可以存储的表中数据更多，更容易命中缓存 数据库并发 数据库事务 事务的四大特性/ACID: A/原子性：单个事务执行期间不可只执行部分操作，即一个事务只会完成或不完成其中所有操作，若操作期间出错则回滚该事物已经进行的操作 C/一致性：事务进行前、结束后，数据库完整性不被破坏。例如A向B转账，A一定会扣钱，B一定会得到等量的钱，不允许A扣钱数量与B得到钱的数量不一致 I/隔离性（操作语句的原子性）：事务在执行某一操作时（可以理解为执行某一条SQL语句时），其他事务不可对这一事务相关的数据进行操作 D/持久性：事务提交后，这一事务对数据的改变是永久的 数据库并发情境下的问题 不可重复读/前后读不一致：一个事务读取到了同一个变量在经其他事务修改前后，值不一致的情况。例如A对变量var进行修改，B前后读取var的值是不一样的 幻影读/前后范围读不一致：对于同一限定范围的数据，一个事务只负责读，另一事物往其中添加数据。这使得读方每次查询得到的数据数量不同 不可重复读和幻影读是很类似的情形，两者在数据的查询范围上有所不同：\n不可重复读针对的是单个数据的值 幻影读针对的是一个范围的数据的总数 脏读/读到被回滚数据：读取到了被回滚前的数据（脏数据）。例如B读取到缓存中由A进行的修改操作后（该修改还未提交），A又回滚了该操作，与数据库中的实际值不同。 丢弃修改/修改的数据被别人改了：两个事务先后修改一个值，前者读取到了后者修改的数据，与自己的修改值不一致 数据库并发问题的解决方案 数据库隔离级别 未提交读：相当于没有隔离，未提交的修改对其他事务可见 提交读：仅提交的修改对其他事务可见，避免了脏读 数据被修改，但未被提交，则该数据不会对其他事务可见，即使此时回滚也不会影响其他事务读取到该数据的结果\n重复读：已有数据被读取期间，其他事务不可修改已有的部分，但允许其他事务插入记录，避免脏读和不可重复读 串行化读：有数据被读取期间，其他事务不可修改该数据 数据库锁机制 锁类型 一般锁 共享锁：允许对数据行/表进行读，在数据行/表有共享锁时，无法申请排它锁（不允许写） 排它锁：允许对数据行/表进行写（更新/删除），在数据行/表有排它锁时，无法申请共享锁、排它锁 意向锁（意向锁一定为表锁） 意向锁的出现是为了表示该表目前有一部分行有共享锁/排它锁，是一种以偏概全的表示形式。\n在向某些行申请共享锁/排它锁时，会先向数据所在表申请对应的意向共享锁/排它锁\n例：要对表中id=6的数据加排它锁前，系统会先向这个表申请意向排它锁\n意向共享锁：意向共享锁代表了目前需要向表中部分行加上共享锁，如果该表已经加有排他锁，则意向共享锁的申请会被阻塞直至排它锁解除 意向排它锁：意向排它锁代表了目前需要向表中部分行加上排他锁，如果该表已经加有共享锁/排他锁，则意向排它锁的申请会被阻塞直至这一非共享锁解除 锁 共享锁 S 排它锁 X 意向共享锁 IS 意向排它锁 IX 共享锁 S √ × √ × 排它锁 X × × × × 意向共享锁 IS √ × √ √ 意向排它锁 IX × × √ √ 死锁：两个事务不提交，由于锁机制导致的两边事务互卡 死锁的产生\n条件\n互斥条件：资源被进程排他地占用。进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。 保持并等待条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。 不可剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放。 循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。 举个例子：\n1 2 3 4 5 6 7 session 1 : session 2： select * from t where id = 1 for update; select * from t where id = 2 for update; update t set name = \u0026#39;Cipher\u0026#39; where id = 2; \u0026lt;!-- 等待session2的第一句的排它锁释放 --\u0026gt; update t set name = \u0026#39;Anima\u0026#39; where id = 1; \u0026lt;!-- 等待session1的第一句的排它锁释放 --\u0026gt; 如果上面两个事务都不提交，则两个事务各自成功申请的申请的的排它锁就不会释放（session1-\u0026gt;id=1的排它锁，session2-\u0026gt;id=2的排它锁）就会相互等待对方的排它锁释放，从而卡住\nMySQL的死锁解决方案\n锁超时：一个事务长时间无法获取锁的时候，主动放弃等待（取消事务），但超时阈值难以确定 阈值太短，容易将一些需要稍等一段时间才可以获取到锁的事务提前取消，然后回滚，之后再重新获取锁。这一操作是没有意义的，造成了性能浪费 阈值太长，容易卡住太多的事务，使得这一数据库给人感觉反应不够快 死锁检测：采用wait-for graph算法 每个锁被什么事务持有（锁的信息链表），被阻塞的事务在等待什么锁（事务等待链表）。 每当一个事务需要阻塞等待某个锁时，就会触发一次wait-for graph算法 从「锁的信息链表」中尝试寻找该锁，如果存在，则查找被哪个事务所持有 根据上一步找到的的事务，在「事务等待链表」中进行查找，看看持有锁的事务是否在等待获取其他锁，如果是，则再去看看另一个持有锁的事务，是否在等待其他锁\u0026hellip;..，经过一系列的判断后，再看看是否会出现闭环 如果出现了闭环，MySQL会选择回滚量最小的事务，如果有回滚量最小的事务不止一个，则回滚其中一个，这一选择需要根据策略的选择来决定（这一点没有查到具体的策略，我能想到的会有：随机、根据事务ID选择、根据事务优先级选择）x ","date":"2025-03-02T14:14:55+08:00","permalink":"https://citadellan.github.io/database/","title":"数据库知识点笔记"}]